\documentclass{article}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{tikz}
\usepackage{algorithm}
\usepackage[shortlabels]{enumitem}
\usepackage[noend]{algpseudocode}

\textwidth=7.6in
\textheight=9.9in
\topmargin=-.9in
\headheight=0in
\headsep=.5in
\hoffset=-1.5in
\setlength\parindent{0pt}


\begin{document}
\begin{center}
    \Large{\textbf{Problem Set 2 Solutions}} \\[0.25ex]
    Calvin Walker
\end{center}
\textbf{Problem 1:} \\[1.0ex]
Let $P$ be the priority queue used by Dijkstra's algorithim, where the entries of $P$ are in increacing order of distance from $s$.
\begin{enumerate}
    \item We start at vertex $s$, $P = [(5, e), (11, c), (14, a)]$
    \item Next is vertex $e$, the length from $s$ to $e$ is $5$, $P = [(8, f), (11, c), (14, a)]$
    \item Next is vertex $f$, the length from $s$ to $f$ is $8$, $P = [(10, c), (11, c), (14, a), (19, d), (20, t)]$
    \item Next is vertex $c$, the length from $s$ to $c$ is $10$, $P = [(6, e), (11, c), (12, a), (14, a), (19, d), (19, d), (20, t), (20, d)]$
    \item We skip $e$ as it has already been seen previously. $P = [(11, c), (12, a), (14, a), (19, d), (19, d), (20, t), (20, d)]$
    \item We skip $c$ as it has already been seen previously. $P = [(12, a), (14, a), (19, d), (19, d), (20, t), (20, d)]$
    \item Next is vertex $a$, the length from $s$ to $a$ is $12$, $P = [(14, a), (18, b), (19, d), (19, d), (20, t), (20, d), (20, b)]$
    \item We skip $a$ as it has already been seen previously. $P = [(18, b), (19, d), (19, d), (20, t), (20, d), (20, b)]$
    \item Next is vertex $b$, the length from $s$ to $b$ is $18$, $P = [(19, d), (19, d), (20, t), (20, t), (20, d), (20, b)]$
    \item Next is vertex $d$, the length from $s$ to $d$ is $19$, $P = [(19, d), (20, t), (20, t), (20, d), (20, b), (21, t)]$
    \item We skip $d$ as it has already been seen previously. $P = [(20, t), (20, t), (20, d), (20, b), (21, t)]$
    \item Finally we reach vertex $t$, the length from $s$ to $t$ is $20$ and the algorithm terminates. 
\end{enumerate}
The final shortest path from $s$ to $t$ is $s, e, f, t$. There is another shortest path of length 20: $s, e, f, c, a, b, t$. \\[1.0ex]
\textbf{Problem 2:}  \\[1.0ex]
A Greedy algorithim to miminize the number of guards would be starting at time $t = 0$, to choose a guard who can work at time $t$ from the set $\{i \in [n]\ |\ a_i \leq t \leq b_i\}$ such that $b_i$ is maximized. Then set $t$ equal to $b_i$ (the start of the next ungaurded interval), and repeat the procedure for the new $t$ until $b_i = T$. \\[0.5ex]
Runtime: An ideal implementation would initially sort the guards in increacing order of their starting times in $O (n \log n)$ time. Then, a variable could be used to track the current position in the sorted array, and for each iteration, progress forward in the array until the optimal guard is found for unguarded time $t$. Since the array of intervals would only be iterated over once after it is sorted, the runtime is $O (n \log n)$. \\[1.0ex]
\underline{Proof}: Let $S = (i_1, \dots ,i_m)$ be the schedule given by the greedy algorithm, and define $t_j(S) = b_{i_j}$ to be the time at which the $j$'th job finishes. 
% For all $j > m$, define $t_j(S) = -\infty$. 
If $S' = (i_1,\dots,i_{m'})$ is another valid schedule, we will first prove that for all $j \in \mathbb{N}$, $t_j(S) \geq t_j(S') $.\\[0.75ex]
By induction on $j$. The base case $j = 1$ is trivial as the greedy algorithm always chooses the guard such that $b_i$ is maximized, so $t_1(S) = b_{i_1} \geq b_{i_1'} = t_1(S')$. For the inductive step, assume that $t_k(S) \geq t_k(S')$. 
% If $t_{k + 1}(S') = - \infty$ then $t_{k + 1}(S) \geq t_{k + 1}(S')$. 
Observe that since both schedules must cover the interval $[0, T]$, $a_{i'_{k + 1}} \leq b_{i'_k} \leq b_{i_k}$, so job $i'_{k + 1}$ is available to $S$. Since $S$ always chooses 
the job with the latest completion time out of the available jobs, $t_{k + 1}(S) = b_{i_{k + 1}} \geq b_{i'_{k + 1}} = t_{k + 1}(S')$, and the inductive case holds. \\[1.0ex]
Since $S$ is ahead of $S'$ for all $j \in \mathbb{N}$, $m \leq m'$, and the correctness of the greedy algorithim is proven.\\[1.0ex]
\textbf{Problem 3:}
\begin{enumerate}[a)]
    \item Let $S$ be the schedule given by the greedy algorithm, and $S'$ be a valid schedule. Consider a job $k \in S$ on the interval $[a_k, b_k]$. Since $k$ is the shortest possible job within the interval $[a_k, b_k]$, as any shorter job would've been chosen first by the Greedy algorithm, it can overlap with at most two other jobs in $S'$. So $S$ has at least half as many jobs as $S'$.
    \item $I = \{[j, j + 1] : j \in [2k] \} \cup \{[2j - \frac{1}{3}, 2j + \frac{1}{3}] : j \in [k]\}$, so the greedy algorithm will choose the $k$ intervals from the latter set while the optimal solution is $2k$ intervals from the former.
\end{enumerate} 

\textbf{Problem 4:} \\[1.0ex]
I would use two heaps: a max heap to store the smaller half of the data points, and a min heap to store the larger half of the data points. For simplicity, if there are an odd number of data points, we will store the extra one in the max heap.
\begin{enumerate}
    \item \texttt{Insert(x)}: 
    \begin{itemize}
        \item Add element to max heap
        \item Push the top element of the max heap to the min heap
        \item If the size of the min heap is greater than the size of the max heap, push the top of the min heap to the max heap
    \end{itemize}
    This procedure will keep the heaps balanced using a constant number of $O( \log n)$ insertions and removals.
    \item \texttt{Find Median}: 
    \begin{itemize}
        \item If the size of the max heap is larger, return the top element. Otherwise, return the average of both heaps. Since at most we just need the top of each heap, this operation takes $O(1)$ time.
    \end{itemize}
\end{enumerate}


\end{document}